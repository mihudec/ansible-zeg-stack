input {
  pipeline {
      address => epnm
  }
} # input

filter {
  fingerprint {
      source              => [ "message" ]
      method              => "SHA1"
      key                 => "Some super secret passphrase for uniqueness."
      concatenate_sources => true
    }

  if "epnm" in [tags] {
    # Grok
    grok {
      patterns_dir => [ "/usr/share/logstash/custom_plugins/patterns" ]
      match => {
        "message" => [
          "(?<log_date>[0-9]{2}/[0-9]{2}/[0-9]{2} [0-9]{2}:[0-9]{2}:[0-9]{2}.[0-9]{3})\s+%{WORD:severity_name}\s+%{GREEDYDATA:message}"
        ]
      }
      overwrite => ["message"]
      add_field => {
        "platform" => "epnm"
      }
    }
  }
    
  mutate {
      gsub => [
          "message",
          "...\n[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(?:\+|-)[0-9]{2}:[0-9]{2} [A-z0-9\-\_]+ ..",
          ""
      ]
      enable_metric => true
      id => "remove_contd_ts"
  }

  mutate {
      gsub => [
          "message",
          "^[0-9]{4}-[0-9]{2}-[0-9]{2}T[0-9]{2}:[0-9]{2}:[0-9]{2}(?:\+|-)[0-9]{2}:[0-9]{2} [A-z0-9\-\_]+",
          ""
      ]
      enable_metric => true
      id => "remove_extra_ts"
  }

  mutate {
    remove_field => ["syslog5424_pri", "@version"]
  }
}
  
output {
  if "_grokparsefailure" not in [tags] {
    file {
      path => "/tmp/epnm_output"
      codec => rubydebug
    } # file
    elasticsearch {
      id => "epnm_test_pipeline"
      hosts => ["http://{{ elk.elasticsearch.name }}:9200"]
      #ssl => false
      #cacert => "/etc/logstash/CA_CHAIN.pem"
      manage_template => false
      ilm_enabled => false
      index => "epnm-%{+YYYY.MM}"
      document_id => "%{fingerprint}"
      user => "logstash"
      password => "{{ elk.users.logstash.password }}"
    } # elasticsearch
  } else {
    file {
      path => "/tmp/epnm_error_output"
      codec => rubydebug
    }
  } # if
} # output
