#jinja2: lstrip_blocks: True
input {
  udp {
    port => "8514"
    type => "syslog-cisco"
    tags => ["cisco"]
  }

  tcp {
    port => "8514"
    type => "syslog-cisco"
    tags => ["cisco"]
  }
}

filter {
  if "cisco" in [tags] {
    # The switches are sending the same message to all syslog servers for redundancy, this allows us to
    ## only store the message in elasticsearch once by generating a hash of the message and using that as
    ## the document_id.
    fingerprint {
      source              => [ "message" ]
      method              => "SHA1"
      key                 => "Some super secret passphrase for uniqueness."
      concatenate_sources => true
    }

    # Parse the log entry into sections.  Cisco doesn't use a consistent log format, unfortunately.
    grok {
      # There are a couple of custom patterns associated with this filter.
      patterns_dir => [ "/usr/share/logstash/custom_plugins/patterns" ]

      match => [
        # IOS
        "message", "%{SYSLOG5424PRI}(%{NUMBER:log_sequence})?:( %{NUMBER}:)? %{GREEDYDATA:message}",
        "message", "%{SYSLOG5424PRI}(%{NUMBER:log_sequence#})?:( %{NUMBER}:)? %{GREEDYDATA:message}",

        # Nexus
        "message", "%{SYSLOG5424PRI}(%{NUMBER:log_sequence#})?: %{GREEDYDATA:message}",
        "message", "%{SYSLOG5424PRI}(%{NUMBER:log_sequence#})?: %{GREEDYDATA:message}"
      ]

      overwrite => [ "message" ]

      remove_field => [ "syslog5424_pri", "@version" ]
    }
  }

}

output {
  file {
    path => "/tmp/test_syslog_output"
    codec => rubydebug
  }
  if "cisco" in [tags] {
    if "_grokparsefailure" not in [tags] {
      pipeline {
        send_to => cisco
      } # pipeline
    } else {
      file {
        path => "/tmp/syslog_cisco_error"
        codec => rubydebug
      }
    } # if _grokparsefailure
  } # if cisco

} # output
