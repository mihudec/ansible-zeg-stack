input {
  pipeline {
      address => cisco
  }
} # input

filter {
  fingerprint {
      source              => [ "message" ]
      method              => "SHA1"
      key                 => "Some super secret passphrase for uniqueness."
      concatenate_sources => true
    }
  # NOTE: The frontend logstash servers set the type of incoming messages.
  #if "cisco" in [tags] {
  #  # Parse the log entry into sections.  Cisco doesn't use a consistent log format, unfortunately.
  #  grok {
  #    # There are a couple of custom patterns associated with this filter.
  #    patterns_dir => [ "/etc/logstash/patterns" ]
  #
  #    match => [
  #      # IOS
  #      "message", "(%{CISCOCLOCKSTATUS:clock_status})?%{CISCOTIMESTAMPTZ:log_date}: %%{CISCO_REASON:facility_short}-%{INT:severity_level}-%{CISCO_REASON:facility_mnemonic}: %{GREEDYDATA:message}",
  #      "message", "%(%{CISCOCLOCKSTATUS:clock_status})?%{CISCOTIMESTAMPTZ:log_date}: %%{CISCO_REASON:facility_short}-%{CISCO_REASON:facility_sub}-%{INT:severity_level}-%{CISCO_REASON:facility_mnemonic}: %{GREEDYDATA:message}",
  #
  #      # Nexus
  #      "message", "%(%{CISCOCLOCKSTATUS:clock_status})?%{NEXUSTIMESTAMP:log_date}: %%{CISCO_REASON:facility_short}-%{INT:severity_level}-%{CISCO_REASON:facility_mnemonic}: %{GREEDYDATA:message}",
  #      "message", "%(%{CISCOCLOCKSTATUS:clock_status})?%{NEXUSTIMESTAMP:log_date}: %%{CISCO_REASON:facility_short}-%{CISCO_REASON:facility_sub}-%{INT:severity_level}-%{CISCO_REASON:facility_mnemonic}: %{GREEDYDATA:message}"
  #    ]
  #
  #    overwrite => [ "message" ]
  #  }
  #}

  if ("cisco" in [tags]) or ("cisco_xr" in [tags]) {
    # Grok for IOS Flavoured Logs
    grok {
      patterns_dir => [ "/usr/share/logstash/custom_plugins/patterns" ]
      match => {
        "message" => [
          "(%{CISCOCLOCKSTATUS:clock_status})?%{CISCOTIMESTAMPTZ:log_date}: %{CISCOTAG:log_tag}: %{GREEDYDATA:message}"
        ]
      }
      overwrite => ["message"]
      add_field => {
        "platform" => "ios"
      }
      tag_on_failure => []
    }
    # Grok for XR Flavoured Logs
    grok {
      patterns_dir => [ "/usr/share/logstash/custom_plugins/patterns" ]
      match => {
        "message" => [
          "%{CISCOXRLINECARD:linecard}:(%{CISCOCLOCKSTATUS:clock_status})?%{CISCOTIMESTAMPTZ:log_date} : %{WORD:process_name}\[%{INT:process_id}\]: %{CISCOTAG:log_tag} : %{GREEDYDATA:message}"
        ]
      } # match
      overwrite => ["message"]
      add_field => {
        "platform" => "ios_xr"
      }
      tag_on_failure => []

    } # grok
    #dissect {
    #  mapping => {
    #    "message" => "%{linecard}:%{log_date} : %{process_name}[%{process-id}]: %{message}"
    #  }
    #} # dissect
    # Grok Cisco Log Tag
    grok {
      patterns_dir => [ "/usr/share/logstash/custom_plugins/patterns" ]
      match => {
        #"log_date" => "(%{CISCOCLOCKSTATUS:clock_status})?%{GREEDYDATA:log_date}"
        "log_tag" => [
          "%%{WORD:facility_short}-%{INT:severity_level}-%{WORD:facility_mnemonic}",
          "%%{WORD:facility_short}-%{WORD:facility_sub}-%{INT:severity_level}-%{WORD:facility_mnemonic}"
        ]
      }
      remove_field => ["log_tag"]
    } # grok
    #grok {
    #  patterns_dir => [ "/etc/logstash/patterns" ]
    #  match => {
    #    "message" => [
    #      "%%{WORD:facility_short}-%{INT:severity_level}-%{WORD:facility_mnemonic} : %{GREEDYDATA:message}",
    #      "%%{WORD:facility_short}-%{WORD:facility_sub}-%{INT:severity_level}-%{WORD:facility_mnemonic} : %{GREEDYDATA:message}"
    #    ]
    #  }
    #  overwrite => ["message"]
    #} # grok
    if ![platform] {
      mutate {
        add_tag => ["_grokparsefailure"]
      }
    }
  } # if cisco_xr

  mutate {
    remove_field => ["syslog5424_pri", "@version"]
  }

  # If we made it here, the grok was sucessful
  if ("cisco" in [tags]) or ("cisco_xr" in [tags]) {
    date {
      match => [
        "log_date",

        # IOS
        "MMM  d YYYY HH:mm:ss",
        "MMM  d HH:mm:ss.SSS",
        "MMM  d HH:mm:ss ZZZ",
        "MMM  d HH:mm:ss.SSS ZZZ",
        "MMM  d YYYY HH:mm:ss",
        "MMM  d YYYY HH:mm:ss.SSS",
        "MMM  d YYYY HH:mm:ss ZZZ", 
        "MMM  d YYYY HH:mm:ss.SSS ZZZ",

        "MMM dd YYYY HH:mm:ss",
        "MMM dd HH:mm:ss.SSS",
        "MMM dd HH:mm:ss ZZZ",
        "MMM dd HH:mm:ss.SSS ZZZ",
        "MMM dd YYYY HH:mm:ss",
        "MMM dd YYYY HH:mm:ss.SSS",
        "MMM dd YYYY HH:mm:ss ZZZ",
        "MMM dd YYYY HH:mm:ss.SSS ZZZ",


        # Nexus
        "YYYY MMM dd HH:mm:ss.SSS",
        "YYYY MMM dd HH:mm:ss ZZZ",
        "YYYY MMM dd HH:mm:ss.SSS ZZZ",

        # Hail marry
        "ISO8601"
      ]
      target => ["timestamp_device"]
      remove_field => ["log_date"]

    }

    if [clock_status] == "*" {
      mutate {
        add_tag => "clock_not_synced"
        remove_field => ["clock_status"]
      }
    } else if [clock_status] == "." {
      mutate {
        add_tag => "clock_sync_lost"
        remove_field => ["clock_status"]
      }
    } else {
      mutate {
        add_tag => "clock_synced"
        remove_field => ["clock_status"]
      }
    }

    mutate {
      rename => {
        "severity_level" => "[log][syslog][severity][code]"
        "facility_short" => "[log][syslog][facility][short]"
        "facility_sub" => "[log][syslog][facility][sub]"
        "facility_mnemonic" => "[log][syslog][facility][mnemonic]"
      } # rename
    } # mutate

    # Translate Cisco Facility Codes
    translate {
      field => "[log][syslog][facility][short]"
      destination => "[log][syslog][facility][full]"
      dictionary_path => "/usr/share/logstash/custom_plugins/translate/cisco_facility.yml"
      fallback => "Unknown"
    } # translate


    translate {
      field => "[log][syslog][severity][code]"
      destination => "[log][syslog][severity][name]"
      dictionary_path => "/usr/share/logstash/custom_plugins/translate/severity.yml"
      fallback => "Unknown"
    } # translate

    mutate {

      convert => {
        "[log][syslog][severity][code]" => "integer"
      } # convert

      copy => {
        "[log][syslog][severity][name]" => "[log][level]"
        "[log][syslog][severity][code]" => "[event][severity]"
        "[log][syslog][facility][short]" => "[cisco][ios][facility]"
      }
    }


    ### SPECIFIC MESSAGE SECTION
    if [log][syslog][facility][mnemonic] == "LOGIN_SUCCESS" {
      grok {
        match => {
          "message" => "Login Success \[user: %{DATA:[source][user][name]}\] \[Source: %{IP:[source][ip]}\] \[localport: %{NUMBER:[destination][port]}\]"
        } # match
      } # grok

      mutate {
        copy => {
          "[source][user]" => "[user]"
        } # copy
      } # mutate
    } # if LOGIN_SUCCESS
    if [log][syslog][facility][mnemonic] == "UPDOWN" {
      if [log][syslog][facility][short] == "LINEPROTO" {
        dissect {
          mapping => {
            "message" => "Line protocol on Interface %{interface}, changed state to %{interface_line_protocol}"
          } # mapping
        } # disect
      } else if [log][syslog][facility][short] == "LINK" {
        dissect {
          mapping => {
              "message" => "Interface %{interface}, changed state to %{interface_state}"
          } # mapping
        } # disect

      } # if
    } # if UPDOWN

  } # if
} # filter

output {
  if "cisco_xr" in [tags] {
    file {
      path => "/tmp/xr_test"
      codec => rubydebug
    }
  }
  if "_grokparsefailure" not in [tags] {
    file {
      path => "/tmp/cisco_output"
      codec => rubydebug
    } # file
    elasticsearch {
      id => "cisco_test_pipeline"
      hosts => ["http://{{ elk.elasticsearch.name }}:9200"]
      #ssl => false
      #cacert => "/etc/logstash/CA_CHAIN.pem"
      manage_template => false
      ilm_enabled => false
      index => "cisco-%{+YYYY.MM}"
      document_id => "%{fingerprint}"
      user => "logstash"
      password => "{{ elk.users.logstash.password }}"
    } # elasticsearch
  } else {
    file {
      path => "/tmp/cisco_error_output"
      codec => rubydebug
    }
  } # if
} # output
